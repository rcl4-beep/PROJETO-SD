module safecrack_fsm_programmable (
    input  logic       clk,         // Clock de 50 MHz da placa
    input  logic       rst,         // Reset
    input  logic [3:0] btn,         // Entradas dos botões (BTN[3:0]), ativas em nível baixo

    output logic [8:0] ledg,        // Saída para os 9 LEDs verdes (LEDG[8:0])
    output logic [17:0] ledr        // Saída para os 18 LEDs vermelhos (LEDR[17:0])
);

    // --- Parâmetros ---
    parameter logic [28:0] LOCKOUT_PERIOD = 29'd500_000_000;
    parameter logic [1:0]  MAX_ERRORS     = 2'd3;
    
    // Senha padrão ao ligar/resetar o sistema
    parameter logic [3:0] DEFAULT_PASS_1 = 4'b1110; // BTN[0]
    parameter logic [3:0] DEFAULT_PASS_2 = 4'b1101; // BTN[1]
    parameter logic [3:0] DEFAULT_PASS_3 = 4'b1011; // BTN[2]
    
    // Botão para entrar no modo de programação (BTN[3])
    parameter logic [3:0] PROG_BUTTON      = 4'b0111;

    // --- Estados da FSM ---
    typedef enum logic [3:0] {
        S_INIT,      // 0: Estado inicial de verificação
        S_STEP1_OK,  // 1: Primeiro passo correto
        S_STEP2_OK,  // 2: Segundo passo correto
        S_UNLOCKED,  // 3: Destravado
        S_LOCKED,    // 4: Bloqueado por 10s
        S_PROG_1,    // 5: Aguardando 1º dígito da nova senha
        S_PROG_2,    // 6: Aguardando 2º dígito da nova senha
        S_PROG_3     // 7: Aguardando 3º dígito da nova senha
    } state_t;

    state_t state, next_state;
    
    // --- Registradores ---
    logic [1:0]  error_count;
    logic [28:0] timer_count;
    logic [25:0] blink_counter; // Contador livre para efeito de piscar
    
    // Registradores para armazenar a senha atual (volátil)
    logic [3:0] pass_step1, pass_step2, pass_step3;
    
    // --- Lógica Sequencial (Registradores) ---
    always_ff @(posedge clk, posedge rst) begin
        if (rst) begin
            state       <= S_INIT;
            error_count <= 2'b0;
            timer_count <= 29'b0;
            // Carrega a senha padrão no reset
            pass_step1  <= DEFAULT_PASS_1;
            pass_step2  <= DEFAULT_PASS_2;
            pass_step3  <= DEFAULT_PASS_3;
        end else begin
            state       <= next_state;
            error_count <= next_error_count;
            timer_count <= next_timer_count;
            // Atualiza a senha se for alterada
            pass_step1  <= next_pass_step1;
            pass_step2  <= next_pass_step2;
            pass_step3  <= next_pass_step3;
        end
        // Contador livre para efeitos visuais
        blink_counter <= blink_counter + 1;
    end

    // --- Lógica Combinacional (Próximo Estado e Saídas) ---
    // (Dividido em dois blocos para clareza)
    logic [1:0]  next_error_count;
    logic [28:0] next_timer_count;
    logic [3:0]  next_pass_step1, next_pass_step2, next_pass_step3;

    always_comb begin
        // Valores padrão
        next_state       = state;
        next_error_count = error_count;
        next_timer_count = timer_count;
        next_pass_step1  = pass_step1; // Mantém a senha por padrão
        next_pass_step2  = pass_step2;
        next_pass_step3  = pass_step3;
        
        logic error_flag = 1'b0;
        logic any_button_pressed = (btn != 4'b1111);

        // Lógica de detecção de erro dinâmica
        case (state)
            S_INIT:     if (any_button_pressed && btn != pass_step1) error_flag = 1'b1;
            S_STEP1_OK: if (any_button_pressed && btn != pass_step2) error_flag = 1'b1;
            S_STEP2_OK: if (any_button_pressed && btn != pass_step3) error_flag = 1'b1;
        endcase

        // Lógica principal da FSM
        case (state)
            S_INIT, S_STEP1_OK, S_STEP2_OK: begin
                if (error_flag) begin
                    next_error_count = error_count + 1;
                    next_state = S_INIT;
                    if (next_error_count >= MAX_ERRORS) begin
                        next_state = S_LOCKED;
                    end
                end else begin
                    case(state)
                        S_INIT:     if (btn == pass_step1) { next_state = S_STEP1_OK; next_error_count = 0; }
                        S_STEP1_OK: if (btn == pass_step2) { next_state = S_STEP2_OK; next_error_count = 0; }
                        S_STEP2_OK: if (btn == pass_step3) { next_state = S_UNLOCKED; next_error_count = 0; }
                    endcase
                end
            end
            
            S_UNLOCKED: begin
                // No estado destravado, aguarda o botão de programação
                if (btn == PROG_BUTTON) begin
                    next_state = S_PROG_1;
                end
            end
            
            S_LOCKED: begin
                if (timer_count < LOCKOUT_PERIOD) begin
                    next_timer_count = timer_count + 1;
                end else begin
                    next_state       = S_INIT;
                    next_error_count = 0;
                    next_timer_count = 0;
                end
            end
            
            // Estados de Programação da Nova Senha
            S_PROG_1: begin
                if (any_button_pressed && btn != PROG_BUTTON) begin
                    next_pass_step1 = btn; // Captura o 1º passo
                    next_state      = S_PROG_2;
                end
            end
            S_PROG_2: begin
                if (any_button_pressed && btn != PROG_BUTTON) begin
                    next_pass_step2 = btn; // Captura o 2º passo
                    next_state      = S_PROG_3;
                end
            end
            S_PROG_3: begin
                if (any_button_pressed && btn != PROG_BUTTON) begin
                    next_pass_step3 = btn; // Captura o 3º passo
                    next_state      = S_INIT; // Retorna ao estado inicial, travando o cofre
                end
            end
            
            default: next_state = S_INIT;
        endcase
    end
    
    // --- Lógica de Saída para os LEDs ---
    always_comb begin
        ledg = 9'b0;
        ledr = 18'b0;
        logic blink_on = blink_counter[24]; // Sinal de piscar ~2Hz

        case (state)
            S_INIT:     ledr[1:0] = error_count;
            S_STEP1_OK: begin ledg[0] = 1'b1; ledr[1:0] = error_count; end
            S_STEP2_OK: begin ledg[1:0] = 2'b11; ledr[1:0] = error_count; end
            S_UNLOCKED: begin
                ledg = 9'h1FF; // Todos os verdes acesos
                // Faz o LEDG[8] piscar para indicar que o modo de programação está disponível
                ledg[8] = blink_on; 
            end
            S_LOCKED:   ledr = blink_counter[25] ? 18'h3FFFF : 18'h0; // Todos os vermelhos piscam
            
            // Feedback visual para o modo de programação
            S_PROG_1:   if(blink_on) ledg[0] = 1'b1; // LED 1 pisca
            S_PROG_2:   if(blink_on) ledg[1:0] = 2'b11; // LEDs 1 e 2 piscam
            S_PROG_3:   if(blink_on) ledg[2:0] = 3'b111; // LEDs 1, 2 e 3 piscam
        endcase
    end

endmodule
