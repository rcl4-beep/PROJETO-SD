module safecrack_fsm (
    input  logic       clk,
    input  logic       rst,
    input  logic [3:0] btn,        // buttons inputs (BTN[3:0])
    output logic [17:15] LEDR,     // acende leds vermelhos do 15 ao 17
    output logic [2:0]  LEDG,      // acende leds verdes do 0 ao 2
    output logic       unlocked    // output: 1 when the safe is unlocked
);
// certo!
    // one-hot encoding
    typedef enum logic [8:0] { 
        B1 = 10'b0000000001,  // def btn1
        B2 = 10'b0000000010,  // def btn2
        B3 = 10'b0000000100,  // def btn3
        S1 = 10'b0000001000,  // BTN = start
        S2 = 10'b0000010000,  // BTN = right
        S3 = 10'b0000100000,  // BTN = right
        D1 = 10'b0001000000,  // BTN != 1 wrong
        D2 = 10'b0010000000,  // BTN != 2 wrong
        D3 = 10'b0100000000,  // BTN != 4 wrong -> block for 10 seconds
        ER = 10'b1000000000   // BTN = right â†’ unlock
    } state_t;
// certo!
    state_t state, next;

    logic [3:0] senha[2:0];

    integer contador;
// certo!
    // state transition
    always_ff @(posedge clk) begin
        if (rst) begin
            state <= B1;
            end
        else begin
            state <= next;
            case (state)
                B1: senha[0] <= btn;
                B2: senha[1] <= btn;
                B3: senha[2] <= btn;
            endcase
        end
    end
// certo!
    // transition logic
    always_comb begin
        LEDG = 3'b000;
        LEDR = 3'b000;
        next = S1; // default
        case (state)
            S1:    next = (btn == B1) ? S2 : D1;
            D1:    LEDR = 3'b001;
                   next = (btn == B1) ? S2 : D1;
            S2:    LEDG = 3'b001;
                   next = (btn == B2) ? S3 : D2;
            D2:    LEDR = 3'b011;
                   next = (btn == B2) ? S3 : D2;
            S3:    LEDG = 3'b011;
                   next = (btn == B3) ? ER : D3;
            D3:    LEDR = 3'b111;
                   contador = contador + 1;
                   if (contador == 500000000) begin
                       next = S1;
                       contador = 0;
                       end
            ER:    LEDG = 3'b111;
                   next = ER;
        endcase
    end

    // output logic
    always_comb begin
        unlocked = (state == ER);
        if (unlocked) begin
            LEDG = 3'b111;
            LEDR = 3'b000;
            end
    end

endmodule
